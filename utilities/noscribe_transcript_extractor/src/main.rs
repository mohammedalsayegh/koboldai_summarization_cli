// Author: Mohammed H Alsaeygh
// Project: HTML to Transcript Converter
//
// Description:
// This Rust utility converts HTML files generated by noScribe into transcript text files. It parses
// the HTML files to extract script text and corresponding start and end times, then writes this data
// to text files. You can specify the path to the HTML file or directory containing HTML files as the
// first argument and the path to the output directory where the text files will be saved as the second
// argument.
//
// How to Use:
// - Compile the code using the Rust compiler.
// - Run the executable with the following command-line arguments:
//   - A directory path containing HTML files or a single HTML file.
//   - The path to the directory where the transcript text files will be saved.
//
// Example Usage:
// $ ./html_to_transcript_converter /path/to/file.html /path/to/output_directory
// $ ./html_to_transcript_converter /path/to/directory /path/to/output_directory
//
// Dependencies:
// - select: For parsing HTML documents.
// - std: Standard Rust library for file I/O and command-line argument parsing.
//
// This tool simplifies the process of converting HTML files produced by noScribe into transcript text
// files, making it easier to work with the data for various applications.

extern crate select;

use select::document::Document;
use select::predicate::Name;
use crate::select::predicate::Predicate;

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

// Define a struct to hold script text and its start and end times
struct ScriptAndDuration {
    script: String,
    start_time: i32,
    end_time: i32,
}

// Function to extract script text and its corresponding start and end times from an HTML file
fn extract_script_and_duration_from_html(html_file: &str) -> Vec<ScriptAndDuration> {
    let mut script_and_duration = Vec::new();
    // Open the HTML file
    if let Ok(file) = File::open(html_file) {
        // Parse the HTML document
        let document = Document::from_read(file).expect("Failed to parse HTML");
        // Find all <a> elements with a 'name' attribute starting with 'ts_'
        for node in document.find(Name("a").and(|n: &select::node::Node| n.attr("name").is_some())) {
            if let Some(name) = node.attr("name") {
                if name.starts_with("ts_") {
                    let script = node.text();
                    let parts: Vec<&str> = name.split('_').collect();
                    if parts.len() == 3 {
                        // Parse start and end times from the 'name' attribute
                        if let (Ok(start_time), Ok(end_time)) = (parts[1].parse::<i32>(), parts[2].parse::<i32>()) {
                            // Create a ScriptAndDuration instance and add it to the vector
                            script_and_duration.push(ScriptAndDuration {
                                script: script,
                                start_time: start_time,
                                end_time: end_time,
                            });
                        }
                    }
                }
            }
        }
    }
    // Return the vector of extracted script and duration data
    script_and_duration
}

// Function to convert an HTML file to a transcript text file
fn convert_html_file(html_file: &Path, output_dir: &Path) {
    let script_and_duration = extract_script_and_duration_from_html(html_file.to_str().unwrap());
    // Create a text file with the same name as the HTML file but with a .txt extension
    let txt_filename = html_file.file_stem().expect("Invalid file name").to_str().unwrap().to_owned() + ".txt";
    let txt_filepath = output_dir.join(txt_filename);
    let mut txt_file = File::create(txt_filepath).expect("Failed to create file");
    // Write script and duration data to the text file
    for data in script_and_duration {
        writeln!(&mut txt_file, "Script: {}", data.script).expect("Failed to write to file");
        writeln!(&mut txt_file, "Start Time: {}", data.start_time).expect("Failed to write to file");
        writeln!(&mut txt_file, "End Time: {}\n", data.end_time).expect("Failed to write to file");
    }
}

// Function to convert all HTML files in a directory to transcript text files
fn convert_html_files_in_directory(directory: &Path, output_dir: &Path) {
    for entry in std::fs::read_dir(directory).expect("Failed to read directory") {
        if let Ok(entry) = entry {
            let path = entry.path();
            if let Some(extension) = path.extension() {
                if extension == "html" {
                    // Convert HTML file to transcript text file
                    convert_html_file(&path, output_dir);
                }
            }
        }
    }
}

fn main() {
    // Get command-line arguments
    let args: Vec<String> = env::args().collect();
    // Ensure correct usage
    if args.len() != 3 {
        println!("Usage:");
        println!("{} <directory|file.html> <output_directory>", args[0]);
        return;
    }

    let input_path = PathBuf::from(&args[1]);
    let output_dir = PathBuf::from(&args[2]);
    // Check if the argument is a directory
    if input_path.is_dir() {
        // Convert all HTML files in the directory to transcript text files
        convert_html_files_in_directory(&input_path, &output_dir);
    // Check if the argument is an HTML file
    } else if input_path.is_file() && input_path.extension() == Some("html".as_ref()) {
        // Convert HTML file to transcript text file
        convert_html_file(&input_path, &output_dir);
    } else {
        println!("Invalid argument: {}", args[1]);
    }

    println!("Conversion completed.");
}

